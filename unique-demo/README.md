# Демонстрация пакета unique в Go

Этот проект демонстрирует возможности нового пакета `unique` в Go 1.23+, который предоставляет функциональность канонизации значений (интернирования или хэш-консинга).

## Что такое канонизация (интернирование)?

Канонизация - это процесс дедупликации значений в памяти, при котором все равные значения ссылаются на одну и ту же область памяти. Это обеспечивает:

- **Экономию памяти** - устранение дублирующихся значений
- **Быстрое сравнение** - сравнение указателей вместо содержимого
- **Эффективное хэширование** - использование адреса как хэша

## Основные возможности пакета unique

### 1. Базовая канонизация
```go
handle := unique.Make("Hello, World!")
canonical := handle.Value()
```

### 2. Сравнение Handle'ов
```go
h1 := unique.Make("test")
h2 := unique.Make("test")
fmt.Println(h1 == h2) // true - быстрое сравнение указателей
```

### 3. Использование с любыми сравнимыми типами
```go
type Person struct {
    Name string
    Age  int
}

handle := unique.Make(Person{Name: "Алексей", Age: 30})
```

## Примеры использования

Запустите демонстрацию:

```bash
go run main.go
```

Программа покажет:

1. **Базовую канонизацию строк** - как одинаковые строки получают одинаковые Handle'ы
2. **Канонизацию структур** - работа с пользовательскими типами
3. **Сравнение производительности** - разница в скорости сравнения
4. **Оптимизацию памяти** - экономия при дедупликации
5. **Кэширование** - эффективное кэширование с Handle'ами как ключами
6. **Использование в картах** - Handle'ы как эффективные ключи

## Когда использовать unique

✅ **Рекомендуется использовать:**
- При частых сравнениях одинаковых значений
- Для экономии памяти при множественных дубликатах
- В качестве ключей для карт и кэшей
- При работе с большими объемами строковых данных

❌ **Не рекомендуется:**
- Для значений, которые редко сравниваются
- При работе с уникальными значениями
- В критичных по производительности участках создания объектов

## Требования

- Go 1.23 или выше
- Пакет `unique` входит в стандартную библиотеку

## Производительность

Наши бенчмарки показывают:

### Сравнение производительности
- **Ускорение сравнений**: 4-7x быстрее обычных сравнений строк
- **Время на одно сравнение**: 
  - Обычные строки: ~2.15 нс
  - Handle'ы: ~0.31 нс (только сравнение указателей)

### Использование памяти
- **Дедупликация**: Значительная экономия при множественных дубликатах
- **Накладные расходы**: Небольшие дополнительные расходы на создание Handle'ов
- **Эффективность**: Особенно выгодно при коэффициенте дедупликации > 2:1

## Практические применения

1. **RBAC системы** - канонизация ролей и разрешений
2. **Конфигурационные системы** - дедупликация настроек
3. **Парсеры и анализаторы** - интернирование ключей и значений  
4. **Кэширование** - эффективные ключи для карт
5. **Многопоточные приложения** - потокобезопасное интернирование

## Рекомендации по использованию

### ✅ Когда использовать:
- Частые сравнения одинаковых значений
- Множественные дубликаты в данных
- Необходимость быстрого хэширования
- Использование значений как ключей карт
- Многопоточные сценарии с разделяемыми данными

### ❌ Когда НЕ использовать:
- Редкие операции сравнения
- Уникальные значения без дубликатов
- Критичные по производительности участки создания объектов
- Очень маленькие значения (где накладные расходы превышают выгоду)

## Безопасность

Пакет `unique` гарантирует:
- Потокобезопасность всех операций
- Детерминированное поведение
- Корректную работу сборщика мусора
- Отсутствие утечек памяти при правильном использовании